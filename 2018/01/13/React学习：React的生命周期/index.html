<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="react," />










<meta name="description" content="关于创建组件的一段历史【早期】创建一个组件有三种方法：通过 React.createClass、ES6 class、Function。【现在】随着React v16.0的发布，React中React.createClass这个方法的实现被移除，facebook提供一个单独的包：create-react-class，用于实现React.createClass的功能。 React.createClas">
<meta name="keywords" content="react">
<meta property="og:type" content="article">
<meta property="og:title" content="React学习：React的生命周期">
<meta property="og:url" content="http://xiaoxiaojing.github.io/2018/01/13/React学习：React的生命周期/index.html">
<meta property="og:site_name" content="XIAOXIAOJING">
<meta property="og:description" content="关于创建组件的一段历史【早期】创建一个组件有三种方法：通过 React.createClass、ES6 class、Function。【现在】随着React v16.0的发布，React中React.createClass这个方法的实现被移除，facebook提供一个单独的包：create-react-class，用于实现React.createClass的功能。 React.createClas">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://xiaoxiaojing.github.io/2018/01/13/React学习：React的生命周期/react_lifecycle_1.png">
<meta property="og:updated_time" content="2018-06-23T09:07:43.735Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="React学习：React的生命周期">
<meta name="twitter:description" content="关于创建组件的一段历史【早期】创建一个组件有三种方法：通过 React.createClass、ES6 class、Function。【现在】随着React v16.0的发布，React中React.createClass这个方法的实现被移除，facebook提供一个单独的包：create-react-class，用于实现React.createClass的功能。 React.createClas">
<meta name="twitter:image" content="http://xiaoxiaojing.github.io/2018/01/13/React学习：React的生命周期/react_lifecycle_1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":13,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://xiaoxiaojing.github.io/2018/01/13/React学习：React的生命周期/"/>





  <title>React学习：React的生命周期 | XIAOXIAOJING</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">XIAOXIAOJING</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">JUST DO IT</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xiaoxiaojing.github.io/2018/01/13/React学习：React的生命周期/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TJ">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XIAOXIAOJING">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">React学习：React的生命周期</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-13T14:24:44+08:00">
                2018-01-13
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2018-06-23T17:07:43+08:00">
                2018-06-23
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React系列/" itemprop="url" rel="index">
                    <span itemprop="name">React系列</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="关于创建组件的一段历史"><a href="#关于创建组件的一段历史" class="headerlink" title="关于创建组件的一段历史"></a>关于创建组件的一段历史</h2><p>【早期】创建一个组件有三种方法：通过 <strong><code>React.createClass</code>、<code>ES6 class</code>、<code>Function</code></strong>。<br>【现在】随着<code>React v16.0</code>的发布，<code>React</code>中<code>React.createClass</code>这个方法的实现被移除，facebook提供一个单独的包：<a href="https://yarnpkg.com/en/package/create-react-class" target="_blank" rel="external"><code>create-react-class</code></a>，用于实现<code>React.createClass</code>的功能。</p>
<h3 id="React-createClass"><a href="#React-createClass" class="headerlink" title="React.createClass"></a><code>React.createClass</code></h3><p>【两个方法】使用<code>React.createClass</code>方法创建组件需要设置两个方法：<code>getInitialState</code>（初始化state）、<code>getDefaultProps</code>（提供默认的props）<br>【需要注意】<code>getDefaultProps</code>只会在组件创建的时候调用一次，<code>getInitialState</code>会在组件每次装载的时候调用<br>【一个🌰】在这个例子中我们给父子组件分别定义了<code>getDefaultProps</code>和<code>getInitialState</code>，由于父组件中加载了两个子组件，所以子组件的<code>getInitialState</code>调用了两次，但是<code>getDefaultProps</code>只调用了一次。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">const React = require(&apos;react&apos;)</div><div class="line">const createReactClass = require(&apos;create-react-class&apos;)</div><div class="line"></div><div class="line">const ChildComponent = createReactClass(&#123;</div><div class="line">  getDefaultProps () &#123;</div><div class="line">    console.log(&apos;create child props&apos;)</div><div class="line">    return &#123;&#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  getInitialState () &#123;</div><div class="line">    console.log(&apos;init child state&apos;)</div><div class="line">    return &#123;&#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  render () &#123;</div><div class="line">    return (</div><div class="line">      &lt;div&gt;</div><div class="line">        this is a child component which create by createClass</div><div class="line">      &lt;/div&gt;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">const ParentComponent = createReactClass(&#123;</div><div class="line">  getDefaultProps () &#123;</div><div class="line">    console.log(&apos;create parent props&apos;)</div><div class="line">    return &#123;&#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  getInitialState () &#123;</div><div class="line">    console.log(&apos;init parent state&apos;)</div><div class="line">    return &#123;&#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  render () &#123;</div><div class="line">    return (</div><div class="line">      &lt;div&gt;</div><div class="line">        this is a parent component which create by createClass</div><div class="line">        &lt;ChildComponent /&gt;</div><div class="line">        &lt;ChildComponent /&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">export default ParentComponent</div></pre></td></tr></table></figure></p>
<p>【程序运行结果】如下所示，<code>getDefaultProps</code>只会在组件创建的时候调用一次，<code>getInitialState</code>会在组件每次装载的时候调用一次。父组件中包含了两个子组件，所以<code>init child state</code>打印了两次。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">create child props</div><div class="line">create parent props</div><div class="line">init parent state</div><div class="line">init child state</div><div class="line">init child state</div></pre></td></tr></table></figure></p>
<p>在上面的🌰中，我们定义了<code>getDefaultProps</code>和<code>getInitialState</code>，它们对于组件来说都是生命周期函数。下面具体说明一下组件的生命周期函数。</p>
<h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p>生命周期（life-cycle）是相对于组件（component）来说的，每个组件都会经历一个从装载（Mount）到卸载（Unmount）的过程。<br>以下讨论的生命周期都是针对于通过<code>ES6 class</code>创建的组件来分析的，这些通过<code>ES6 class</code>创建的组件会被添加tag（tag值为：<code>ClassComponent</code>）。这类组件有以下生命周期函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">constructor(props)</div><div class="line">componentWillMount()</div><div class="line">componentDidMount()</div><div class="line">componentWillReceiveProps(nextProps, nextState, newContext)</div><div class="line">shouldComponentUpdate(prevProps, prevState)</div><div class="line">componentWillUpdate(newProps, newState, newContext)</div><div class="line">componentDidUpdate(prevProps, prevState)</div><div class="line">componentWillUnmount()</div><div class="line">render()</div><div class="line">componentDidCatch(error, info)</div></pre></td></tr></table></figure></p>
<p>他们的执行情况如下图所示</p>
<div style="max-width:600px;"><br><img src="/2018/01/13/React学习：React的生命周期/react_lifecycle_1.png" alt="react_lifecycle_1.png" title=""><br></div>

<h2 id="Unmounting阶段"><a href="#Unmounting阶段" class="headerlink" title="Unmounting阶段"></a>Unmounting阶段</h2><p>在组件卸载阶段，这个阶段会调用<code>componentWillUnmount</code>。<br>会导致组件卸载的情况：组件被删除。<br>在<code>componentWillUnmount</code>中可以做：清除定时器、取消网络请求、清除在componentDidMount中定义的监听器</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>当组件卸载的时候，对于<code>ES6 class</code>创建的组件，会执行tag为<code>ClassComponent</code>的对应系列程序，最终会调用<code>callComponentWillUnmountWithTimer</code>这个方法，进而调用<code>componentWillUnmount</code>方法。（<a href="https://github.com/facebook/react/blob/v16.2.0/packages/react-reconciler/src/ReactFiberCommitWork.js" target="_blank" rel="external">ReactFiberCommitWork.js</a>）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var callComponentWillUnmountWithTimer = function(current, instance) &#123;</div><div class="line">  startPhaseTimer(current, &apos;componentWillUnmount&apos;);</div><div class="line">  instance.props = current.memoizedProps;</div><div class="line">  instance.state = current.memoizedState;</div><div class="line">  instance.componentWillUnmount(); // 调用componentWillUnmount</div><div class="line">  stopPhaseTimer();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>如下所示，点击button后子组件会被删除，在移除之前会调用<code>componentWillUnmount</code>（除此之外，不会再调用其他生命周期函数），输出<code>component will unmount</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">import React, &#123;Component&#125; from &apos;react&apos;</div><div class="line"></div><div class="line">export default class MountTest extends Component &#123;</div><div class="line">  constructor (props, context) &#123;</div><div class="line">    super(props)</div><div class="line">    this.state = &#123;show: true&#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  componentWillUnmount () &#123;</div><div class="line">    console.log(&apos;component did unmount&apos;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  handler = () =&gt; &#123;</div><div class="line">    this.setState(&#123;show: false&#125;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render () &#123;</div><div class="line">    return (</div><div class="line">      &lt;div&gt;</div><div class="line">        &#123;this.state.show &amp;&amp; &lt;ChildComponent /&gt;&#125;</div><div class="line">        test the unmount process, this is a parent</div><div class="line">        &lt;button onClick=&#123;this.handler&#125;&gt;remove&lt;/button&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ChildComponent extends Component &#123;</div><div class="line">  constructor (props, context) &#123;</div><div class="line">    super(props)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  componentWillUnmount () &#123;</div><div class="line">    console.log(&apos;component will unmount&apos;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render () &#123;</div><div class="line">    return (</div><div class="line">      &lt;div&gt;</div><div class="line">        the child component will be remove</div><div class="line">      &lt;/div&gt;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Mounting阶段"><a href="#Mounting阶段" class="headerlink" title="Mounting阶段"></a>Mounting阶段</h2><p>这个阶段会依次调用<code>constructor</code>、<code>componentWillMount</code>、<code>render</code>、<code>componentDidMount</code>。<br>其中<code>constructor</code>、<code>componentWillMount</code>、<code>componentDidMount</code>有且只会被调用一次。</p>
<p>React会先判断组件有没有装载，如果没有就执行装载的流程，如果有装载就执行更新的流程。（<a href="https://github.com/facebook/react/blob/v16.2.0/packages/react-reconciler/src/ReactFiberBeginWork.js" target="_blank" rel="external">ReactFiberBeginWork.js</a>）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function updateClassComponent (current, workInProgress, renderExpirationTime) &#123;</div><div class="line">  let shouldUpdate</div><div class="line">  if (current == null) &#123; // 如果当前节点不存在，就进行初始化操作</div><div class="line">    if (!workInProgress.stateNode) &#123;</div><div class="line">        // In the initial pass we might need to construct the instance.</div><div class="line">        constructClassInstance(workInProgress, workInProgress.pendingProps);</div><div class="line">        mountClassInstance(workInProgress, renderExpirationTime);</div><div class="line">        shouldUpdate = true;</div><div class="line">      &#125;</div><div class="line">  &#125; else &#123;</div><div class="line">    shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="constructor-props-context"><a href="#constructor-props-context" class="headerlink" title="constructor(props, context)"></a>constructor(props, context)</h3><p>在<code>constructor</code>初始化<code>state</code>，执行<code>this.state={...}</code>（相当于调用<code>getInitialState</code>方法）<br>在<code>constructor</code>中必须调用<code>super(props)</code>，这样才能使得<code>this.props</code>有值</p>
<p><code>workInProgress.type</code>其指向当前正在被装载的组件，执行<code>new ctor(props, context)</code>时，会调用组件的生命周期函数<code>constructor</code>。（<a href="https://github.com/facebook/react/blob/v16.2.0/packages/react-reconciler/src/ReactFiberClassComponent.js" target="_blank" rel="external">ReactFiberClassComponent.js</a>）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function constructClassInstance(workInProgress: Fiber, props: any): any &#123;</div><div class="line">  const ctor = workInProgress.type; // 获取组件</div><div class="line">  const unmaskedContext = getUnmaskedContext(workInProgress);</div><div class="line">  const needsContext = isContextConsumer(workInProgress);</div><div class="line">  const context = needsContext ? getMaskedContext(workInProgress, unmaskedContext): emptyObject;</div><div class="line">  const instance = new ctor(props, context); // 创建组件实例</div><div class="line">  // ...</div><div class="line">  return instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount()"></a>componentWillMount()</h3><p>在这个生命周期函数中可以执行<code>this.setState</code>更新state，使得后续访问的state为更新后的state。并且调用<code>this.setState</code>不会触发二次更新。</p>
<p>在<code>mountClassInstance</code>方法中有一句注释：<code>If we had additional state updates during this life-cycle, let&#39;s process them now</code>。当state有变化时，会调用<code>updater.enqueueReplaceState</code>将更新加入到更新队列中，如果<code>updateQueue</code>有值，就会调用<code>processUpdateQueue</code>方法，执行更新操作。 （<a href="https://github.com/facebook/react/blob/v16.2.0/packages/react-reconciler/src/ReactFiberClassComponent.js" target="_blank" rel="external">ReactFiberClassComponent.js</a>）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function mountClassInstance () &#123;</div><div class="line">  // ...</div><div class="line">  if (typeof instance.componentWillMount === &apos;function&apos;) &#123;</div><div class="line">    callComponentWillMount(workInProgress, instance);</div><div class="line">    // If we had additional state updates during this life-cycle, let&apos;s process them now.</div><div class="line">    const updateQueue = workInProgress.updateQueue;</div><div class="line">    if (updateQueue !== null) &#123;</div><div class="line">      instance.state = processUpdateQueue(current, workInProgress, updateQueue, instance, props, renderExpirationTime);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  // ...</div><div class="line">&#125;</div><div class="line">function callComponentWillMount(workInProgress, instance) &#123;</div><div class="line">    startPhaseTimer(workInProgress, &apos;componentWillMount&apos;);</div><div class="line">    const oldState = instance.state;</div><div class="line">    instance.componentWillMount();</div><div class="line">    stopPhaseTimer();</div><div class="line">    if (oldState !== instance.state) &#123;</div><div class="line">      // 会将更新加入更新队列</div><div class="line">      updater.enqueueReplaceState(instance, instance.state, null);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount()"></a>componentDidMount()</h3><p>组件装载完成后调用<code>componentDidMount</code>，可以在这个方法中建立网络连接获取数据，或者声明监听器</p>
<p>在<code>mountClassInstance</code>方法中，也有<code>componentDidMount</code>的对应逻辑。在这里只是将<code>effectTag</code>的值设置为<code>Update</code>。 （<a href="https://github.com/facebook/react/blob/v16.2.0/packages/react-reconciler/src/ReactFiberClassComponent.js" target="_blank" rel="external">ReactFiberClassComponent.js</a>）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function mountClassInstance () &#123;</div><div class="line">  // ...</div><div class="line">  if (typeof instance.componentDidMount === &apos;function&apos;) &#123;</div><div class="line">    workInProgress.effectTag |= Update;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Fiber执行Commit时，会执行<code>commitLifeCycles</code>，如果该组件的<code>effetctTag</code>为<code>Update</code>，就会执行生命周期函数<code>componentDidMount</code>或<code>componentDidUpdate</code>。逻辑为：如果当前组件第一次Mount，那么执行<code>componentDidMount</code>，如果已经装载过，则执行<code>componentDidUpdate</code>。(<a href="https://github.com/facebook/react/blob/v16.2.0/packages/react-reconciler/src/ReactFiberCommitWork.js" target="_blank" rel="external">ReactFiberCommitWork</a>)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function commitLifeCycles(current: Fiber | null, finishedWork: Fiber): void &#123;</div><div class="line">  switch (finishedWork.tag) &#123;</div><div class="line">    case ClassComponent: &#123;</div><div class="line">      const instance = finishedWork.stateNode;</div><div class="line">      // 这里做 &amp; 运算，是一个位运算，用于判断是否是更新操作</div><div class="line">      if (finishedWork.effectTag &amp; Update) &#123;  </div><div class="line">        if (current === null) &#123; // 组件第一次装载</div><div class="line">          startPhaseTimer(finishedWork, &apos;componentDidMount&apos;);</div><div class="line">          instance.props = finishedWork.memoizedProps;</div><div class="line">          instance.state = finishedWork.memoizedState;</div><div class="line">          instance.componentDidMount();</div><div class="line">          stopPhaseTimer();</div><div class="line">        &#125; else &#123;</div><div class="line">          // ...</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      const updateQueue = finishedWork.updateQueue;</div><div class="line">      if (updateQueue !== null) &#123;</div><div class="line">        commitCallbacks(updateQueue, instance);</div><div class="line">      &#125;</div><div class="line">      return;</div><div class="line">    &#125;</div><div class="line">        // ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Updating阶段"><a href="#Updating阶段" class="headerlink" title="Updating阶段"></a>Updating阶段</h2><p>这个阶段会依次调用<code>componentWillReceiveProps</code>、<code>shouldComponentUpdate</code>、<code>componentWillUpdate</code>、<code>render</code>、<code>componentDidUpdate</code>。<br>只有当props有变化时，才会调用<code>componentWillReceiveProps</code>。<br>如果<code>shouldComponentUpdate</code>返回false，<code>componentWillUpdate</code>、<code>render</code>、<code>componentDidUpdate</code>不会再执行。</p>
<p>在Mount阶段的源码分析有提到：React会先判断组件有没有装载，如果没有就执行装载的流程，如果有装载就执行更新的流程。所以执行更新流程时，会执行<code>updateClassInstance</code>方法，这个方法中定义了如何执行<code>componentWillReceiveProps</code>，<code>componentWillUpdate</code>。（<a href="https://github.com/facebook/react/blob/v16.2.0/packages/react-reconciler/src/ReactFiberClassComponent.js" target="_blank" rel="external">ReactFiberClassComponent.js</a>）</p>
<h3 id="componentWillReceiveProps-newProps-newContext"><a href="#componentWillReceiveProps-newProps-newContext" class="headerlink" title="componentWillReceiveProps(newProps, newContext)"></a>componentWillReceiveProps(newProps, newContext)</h3><p><strong>同<code>componentWillMount</code>一样，在<code>componentWillReceiveProps</code>，也给予了用户一次修改state的机会，同样在这个方法里调用<code>setState</code>是不会触发二次更新的。</strong></p>
<p>在<code>updateClassInstance</code>方法中有这样一段代码。很简单的逻辑，就是当<code>componentWillReceiveProps</code>方法存在时，<strong>并且props或context有变化</strong> 时，要执行<code>callComponentWillReceiveProps</code>。<br>在这里需要特别注意一个事：当父组件更新时，子组件的<code>oldProps</code>与<code>newProps</code>始终是不相等的，所以父组件更新时，子组件的<code>componentWillReceiveProps</code>总是会被调用。但是当子组件更新state时，由于<code>oldProps</code>和<code>newProps</code>是相等的，所以不会调用<code>componentWillReceiveProps</code>。<br>在执行完<code>callComponentWillReceiveProps</code>后，如果更新队列<code>updateQueue!==null</code>，那么需要更新state的值，这里是直接调用<code>processUpdateQueue</code>更新state，所以不会触发二次更新。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">if (</div><div class="line">  typeof instance.componentWillReceiveProps === &apos;function&apos; &amp;&amp;</div><div class="line">  (oldProps !== newProps || oldContext !== newContext)</div><div class="line">) &#123;</div><div class="line">  callComponentWillReceiveProps(</div><div class="line">    workInProgress,</div><div class="line">    instance,</div><div class="line">    newProps,</div><div class="line">    newContext,</div><div class="line">  );</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (workInProgress.updateQueue !== null) &#123;</div><div class="line">  newState = processUpdateQueue(current,</div><div class="line">    workInProgress,</div><div class="line">    workInProgress.updateQueue,</div><div class="line">    instance,</div><div class="line">    newProps,</div><div class="line">    renderExpirationTime,</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>callComponentWillReceiveProps</code>会调用组件的<code>componentWillReceiveProps</code>方法，并且如果state有改变，将更新加入到更新队列中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function callComponentWillReceiveProps(</div><div class="line">    workInProgress,</div><div class="line">    instance,</div><div class="line">    newProps,</div><div class="line">    newContext,</div><div class="line">) &#123;</div><div class="line">  startPhaseTimer(workInProgress, &apos;componentWillReceiveProps&apos;);</div><div class="line">  const oldState = instance.state;</div><div class="line">  instance.componentWillReceiveProps(newProps, newContext);</div><div class="line">  stopPhaseTimer();</div><div class="line">  // ....</div><div class="line"></div><div class="line">  if (instance.state !== oldState) &#123;</div><div class="line">    updater.enqueueReplaceState(instance, instance.state, null);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="shouldComponentUpdate-newProps-newState-newContext"><a href="#shouldComponentUpdate-newProps-newState-newContext" class="headerlink" title="shouldComponentUpdate(newProps, newState, newContext)"></a>shouldComponentUpdate(newProps, newState, newContext)</h3><p><code>shouldComponentUpdate</code>，在组件每次更新的时候都会调用，除非组件调用了<code>forceUpdate</code>。<br>同样在<code>updateClassInstance</code>方法中有这样一个逻辑，先计算<code>shouldUpdate</code>，然后根据shouldUpdate去判断是否执行更新<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const shouldUpdate = checkShouldComponentUpdate(</div><div class="line">  workInProgress,</div><div class="line">  oldProps,</div><div class="line">  newProps,</div><div class="line">  oldState,</div><div class="line">  newState,</div><div class="line">  newContext,</div><div class="line">);</div><div class="line">if (shouldUpdate) &#123;</div><div class="line">  // 执行更新</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>checkShouldComponentUpdate</code>函数中，从<code>workInProgress.updateQueue.hasForceUpdate</code>这句话我们可以知道，如果在更新过程中有调用<code>forceUpdate</code>方法，会跳过<code>shouldComponentUpdate</code>方法，执行更新流程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext) &#123;</div><div class="line">  if (oldProps === null || (workInProgress.updateQueue !== null &amp;&amp; workInProgress.updateQueue.hasForceUpdate)) &#123;</div><div class="line">    // If the workInProgress already has an Update effect, return true</div><div class="line">    return true;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  const instance = workInProgress.stateNode;</div><div class="line">  const type = workInProgress.type;</div><div class="line">  // 如果有`shouldComponentUpdate`，就执行它，并将其返回值赋值给`shouldUpdate`</div><div class="line">  if (typeof instance.shouldComponentUpdate === &apos;function&apos;) &#123;</div><div class="line">    startPhaseTimer(workInProgress, &apos;shouldComponentUpdate&apos;);</div><div class="line">    const shouldUpdate = instance.shouldComponentUpdate(newProps, newState, newContext,);</div><div class="line">    stopPhaseTimer();</div><div class="line">  &#125;</div><div class="line">  return shouldUpdate;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="componentWillUpdate-newProps-newState-newContext"><a href="#componentWillUpdate-newProps-newState-newContext" class="headerlink" title="componentWillUpdate(newProps, newState, newContext)"></a>componentWillUpdate(newProps, newState, newContext)</h3><p>在<code>updateClassInstance</code>方法中，当<code>shouldUpdate</code>为true时就会执行更新程序，如果<code>componentWillUpdate</code>存在，就会执行它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (shouldUpdate) &#123;</div><div class="line">  if (typeof instance.componentWillUpdate === &apos;function&apos;) &#123;</div><div class="line">    startPhaseTimer(workInProgress, &apos;componentWillUpdate&apos;);</div><div class="line">    instance.componentWillUpdate(newProps, newState, newContext);</div><div class="line">    stopPhaseTimer();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="componentDidUpdate-prevProps-prevState"><a href="#componentDidUpdate-prevProps-prevState" class="headerlink" title="componentDidUpdate(prevProps, prevState)"></a>componentDidUpdate(prevProps, prevState)</h3><p>在<code>updateClassInstance</code>方法中，当<code>shouldUpdate</code>为true时就会执行更新程序，如果<code>componentDidUpdate</code>存在，设置<code>effectTag</code>为<code>Update</code>，并等待更新完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (shouldUpdate) &#123;</div><div class="line">  if (typeof instance.componentDidUpdate === &apos;function&apos;) &#123;</div><div class="line">    workInProgress.effectTag |= Update;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>componentDidMount</code>的分析中提到，（当组件更新完成，会执行<code>commitLifeCycles</code>方法，逻辑为：如果当前组件第一次Mount，那么执行，如果已经装载过，则执行<code>componentDidUpdate</code>）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">if (current === null) &#123;</div><div class="line">  // 执行componentDidMount</div><div class="line">&#125; else &#123;</div><div class="line">  // 执行componentDidUpdate</div><div class="line">  const prevProps = current.memoizedProps;</div><div class="line">  const prevState = current.memoizedState;</div><div class="line">  startPhaseTimer(finishedWork, &apos;componentDidUpdate&apos;);</div><div class="line">  instance.props = finishedWork.memoizedProps;</div><div class="line">  instance.state = finishedWork.memoizedState;</div><div class="line">  instance.componentDidUpdate(prevProps, prevState);</div><div class="line">  stopPhaseTimer();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Error-Handing"><a href="#Error-Handing" class="headerlink" title="Error Handing"></a>Error Handing</h2><h3 id="componentDidCatch-error-info"><a href="#componentDidCatch-error-info" class="headerlink" title="componentDidCatch(error, info)"></a>componentDidCatch(error, info)</h3><p>当子组件的周期函数中有错误发生时，错误会被父组件的componentDidCatch捕获<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function commitErrorHandling(effectfulFiber: Fiber) &#123;</div><div class="line">  // 如果effectfulFiber.tag为ClassComponent，就调用componentDidCatch来处理错误</div><div class="line">  switch (effectfulFiber.tag) &#123;</div><div class="line">    case ClassComponent:</div><div class="line">      const instance = effectfulFiber.stateNode;</div><div class="line">      const info: HandleErrorInfo = &#123;</div><div class="line">        componentStack: capturedError.componentStack,</div><div class="line">      &#125;;</div><div class="line">      instance.componentDidCatch(capturedError.error, info);</div><div class="line">      return;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="React宏观上的渲染"><a href="#React宏观上的渲染" class="headerlink" title="React宏观上的渲染"></a>React宏观上的渲染</h3><p>React数据传递是置顶向下的，React整体上的渲染也是置顶向下的。可以将React组件的渲染操作想象成一个先入先出的队列，组件入队列之前执行render以及render之前的生命周期函数，出队列之前执行render之后的生命周期函数。如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 组件第一次加载</div><div class="line">parent constructor → parent will mount → parent render → child constructor → child will mount → child render → child did mount → parent did mount</div><div class="line">// 组件更新</div><div class="line">parent will update → parent render → child will update → child render → child did update → parent did update</div></pre></td></tr></table></figure></p>
<h3 id="从源码看组件的渲染"><a href="#从源码看组件的渲染" class="headerlink" title="从源码看组件的渲染"></a>从源码看组件的渲染</h3><p>在组件开始渲染时，Fiber会首先创建一颗Fiber tree，并clone一个的副本：workInProgress。<br>更新时，对比current和workInProgress的差异，Fiber将有变化的Component的effectTag为Update。<br>在对比current和workInProgress的过程中会调用constructor、componentWillMount、componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate。如果在componentWillMount和componentWillReceiveProps中调用了setState，对state的更改会被加入更新队列，随后将立即执行更新队列得到新的state。<br>当完成current和workInProgress比较后，Fiber就会执行Commit完成渲染，这个阶段会调用componentDidMount、componentDidUpdate、componentWillUnmount。如果componentDidMount、componentDidUpdate有调用setState，会触发二次渲染。</p>
<h3 id="无状态组件的渲染"><a href="#无状态组件的渲染" class="headerlink" title="无状态组件的渲染"></a>无状态组件的渲染</h3><p>通过<code>Function</code>创建的组件是无状态组件，它是没有生命周期，也不需要管理state，每次都会被重新渲染。</p>
<h3 id="有状态组件的渲染"><a href="#有状态组件的渲染" class="headerlink" title="有状态组件的渲染"></a>有状态组件的渲染</h3><p>通过<code>ES6 class</code>创建的组件是有生命周期函数的，可以管理自己的state。<br>这类组件的渲染分为了三个阶段：Mount、Unmount、Update。组件的Mount阶段只会在组件装载的时候执行一次，Update阶段会在组件props或state有变化时执行。<br>Mount阶段会执行的周期函数有：constructor、componentWillMount、render、componentDidMount。<br>Update阶段会执行的周期函数有：componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render、componentDidUpdate<br>在React v16.0以后新增一个阶段：Error Handing，这个阶段会执行周期函数：componentDidCatch</p>
<h4 id="props变化引起的update"><a href="#props变化引起的update" class="headerlink" title="props变化引起的update"></a>props变化引起的update</h4><p>组件的props变化导致组件更新时，会调用componentWillReceiveProps。<br>注意：父组件每次更新后，传递给子组件的props都会变化。这就意味着父组件更新后，子组件默认都会更新。</p>
<h4 id="state变化引起的update"><a href="#state变化引起的update" class="headerlink" title="state变化引起的update"></a>state变化引起的update</h4><p>组件自身的state变化导致组件更新时，不会调用componentWillReceiveProps。<br>注意：子组件更新不会引起父组件更新，因为在React中更新时局部的。</p>
<h3 id="改变state"><a href="#改变state" class="headerlink" title="改变state"></a>改变state</h3><p>通过setState来更改组件的state，并且setState是一个异步的动作。调用<code>setState</code>对state的更改都会被放到更新队列中。所以在生命周期函数中调用setState后，立即访问state还会是旧的值。</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>默认情况下，父组件更新，其下的所有子组件都会更新，因为虽然props的值没有变化，但是它的引用变了。<br>默认情况下，<code>shouldComponentUpdate</code>默认返回<code>true</code>，组件state即使没有变化，只要调用了<code>setState</code>，组件都会更新。<br>可以在<code>shouldComponentUpdate</code>里，通过判断oldProps和newProps的值是否相等，oldState和newState的值是否相等来控制组件的更新，达到性能优化的目的。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/react/" rel="tag"># react</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/03/ES6学习：Iterator和Generator/" rel="next" title="ES6学习：Iterator和Generator">
                <i class="fa fa-chevron-left"></i> ES6学习：Iterator和Generator
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/17/React学习：React-Element/" rel="prev" title="React学习：React Element">
                React学习：React Element <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMjg3NC85NDM1"></div>
    </div>
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/my.jpg"
                alt="TJ" />
            
              <p class="site-author-name" itemprop="name">TJ</p>
              <p class="site-description motion-element" itemprop="description">xiaoxiaojing's blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">47</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/xiaoxiaojing" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:happyxxj123@gmail.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i></a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#关于创建组件的一段历史"><span class="nav-number">1.</span> <span class="nav-text">关于创建组件的一段历史</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#React-createClass"><span class="nav-number">1.1.</span> <span class="nav-text">React.createClass</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组件的生命周期"><span class="nav-number">2.</span> <span class="nav-text">组件的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unmounting阶段"><span class="nav-number">3.</span> <span class="nav-text">Unmounting阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#源码分析"><span class="nav-number">3.1.</span> <span class="nav-text">源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例说明"><span class="nav-number">3.2.</span> <span class="nav-text">实例说明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mounting阶段"><span class="nav-number">4.</span> <span class="nav-text">Mounting阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#constructor-props-context"><span class="nav-number">4.1.</span> <span class="nav-text">constructor(props, context)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#componentWillMount"><span class="nav-number">4.2.</span> <span class="nav-text">componentWillMount()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#componentDidMount"><span class="nav-number">4.3.</span> <span class="nav-text">componentDidMount()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Updating阶段"><span class="nav-number">5.</span> <span class="nav-text">Updating阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#componentWillReceiveProps-newProps-newContext"><span class="nav-number">5.1.</span> <span class="nav-text">componentWillReceiveProps(newProps, newContext)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shouldComponentUpdate-newProps-newState-newContext"><span class="nav-number">5.2.</span> <span class="nav-text">shouldComponentUpdate(newProps, newState, newContext)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#componentWillUpdate-newProps-newState-newContext"><span class="nav-number">5.3.</span> <span class="nav-text">componentWillUpdate(newProps, newState, newContext)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#componentDidUpdate-prevProps-prevState"><span class="nav-number">5.4.</span> <span class="nav-text">componentDidUpdate(prevProps, prevState)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Error-Handing"><span class="nav-number">6.</span> <span class="nav-text">Error Handing</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#componentDidCatch-error-info"><span class="nav-number">6.1.</span> <span class="nav-text">componentDidCatch(error, info)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">7.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#React宏观上的渲染"><span class="nav-number">7.1.</span> <span class="nav-text">React宏观上的渲染</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从源码看组件的渲染"><span class="nav-number">7.2.</span> <span class="nav-text">从源码看组件的渲染</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无状态组件的渲染"><span class="nav-number">7.3.</span> <span class="nav-text">无状态组件的渲染</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有状态组件的渲染"><span class="nav-number">7.4.</span> <span class="nav-text">有状态组件的渲染</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#props变化引起的update"><span class="nav-number">7.4.1.</span> <span class="nav-text">props变化引起的update</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#state变化引起的update"><span class="nav-number">7.4.2.</span> <span class="nav-text">state变化引起的update</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#改变state"><span class="nav-number">7.5.</span> <span class="nav-text">改变state</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#性能优化"><span class="nav-number">7.6.</span> <span class="nav-text">性能优化</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TJ</span>

  
</div>








  <div class="footer-custom">my love, I will find you!</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  










  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  








  





  

  

  

  

  

  

</body>
</html>
